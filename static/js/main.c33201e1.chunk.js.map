{"version":3,"sources":["game/Word.js","game/Board.js","game/Tray.js","game/Picture.js","game/NextButton.js","game/Game.js","game/Puzzles.js","App.js","serviceWorker.js","index.js"],"names":["WordContainer","styled","isSelected","coords","direction","otherProps","x","y","length","Square","isLocked","Word","props","word","onSelectWord","tempLettersState","onRemoveTempLetter","text","id","squares","map","letter","index","displayLetter","isVisible","tempLetter","key","onClick","GridContainer","gridSize","Board","puzzle","puzzleState","selectedWordIndex","words","fixedWords","forEach","wordIndex","fixedText","letterIndex","isLetterDone","push","wordBlocks","Container","div","LetterBlock","isUsed","Tray","letterStates","onPickTempLetter","letterBlocks","letterState","handlePickLetter","PictureContainer","img","PictureOverlay","Picture","url","useState","isBig","setIsBig","handleClick","old","src","alt","StyledNextButton","button","NextButton","onNextLevel","Base","makePuzzleState","isDone","Array","fill","Game","console","log","setSelectedWordIndex","setTempLettersState","setLetterStates","isFinished","setIsFinished","setPuzzleState","useEffect","correctAnswer","every","i","p","wordState","overlap","newWordState","selectedWord","newLetterStates","letters","char","charIndex","usedIndex","findIndex","selectedLetterIndex","letterToRestore","trayIndex","otherLetterState","picture","selectedLetter","toUpdateIndex","Puzzles","randomLetters","split","randomLetter","Math","floor","random","this","result","getRandomLettersFor","shuffle","otherWord","x2","y2","j","indexOf","App","currentLevel","setCurrentLevel","oldLevel","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.c33201e1.chunk.js","sourcesContent":["import React from 'react'\nimport PropTypes from 'prop-types'\nimport styled from 'styled-components'\n\nconst WordContainer = styled(({ isSelected, coords, direction, ...otherProps }) => <div {...otherProps} />)`\n\tdisplay: flex;\n\tflex-direction: ${({ direction }) => direction};\n  justify-content: center;\n  z-index: ${({ isSelected}) => isSelected ? '1' : 'auto'}\n\tgrid-column-start: ${({ coords }) => coords.x};\n\tgrid-row-start: ${({ coords }) => coords.y};\n\t${({ direction }) => direction === 'row' ? 'grid-column-end' : 'grid-row-end'}: span ${({ length }) => length};\n`\n\nconst Square = styled(({ isSelected, isLocked, ...otherProps }) => <div {...otherProps} />)`\n  flex: 1 1 0;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  background-color: ${({ isLocked, isSelected }) => \n    isLocked ? 'rgb(240, 240, 140)' : \n      isSelected ? 'rgb(220, 220, 240)' : 'rgb(240, 240, 240)'};\n\tmargin: 1px;\n  border-radius: 5px;\n  user-select: none;\n  font-size: 35px;\n  text-transform: uppercase;\n  font-family: sans-serif;\n`\n\nconst Word = props => {\n\tconst { word, onSelectWord, isSelected, tempLettersState, onRemoveTempLetter } = props\n\tconst {\n\t\ttext,\n\t\tcoords,\n\t\tdirection,\n\t\tid,\n\t} = word\n\n\tconst squares = text.map((letter, index) => {\n\t\tlet displayLetter = letter.isVisible ? letter.letter : ''\n\t\tif (isSelected) {\n\t\t\tdisplayLetter= tempLettersState[index].tempLetter\n\t\t}\n\t\treturn (\n\t\t\t<Square isSelected={isSelected} isLocked={letter.isVisible} key={index} onClick={() => isSelected && onRemoveTempLetter(index)}>{displayLetter}</Square>\n\t\t)\n\t})\n\n\treturn (\n\t\t<WordContainer\n\t\t\tonClick={() => {\n        onSelectWord(id)}}\n\t\t\tisSelected={isSelected}\n\t\t\tcoords={coords}\n\t\t\tdirection={direction}\n\t\t\tlength={text.length}\n\t\t>\n\t\t\t{squares}\n\t\t</WordContainer>\n\t)\n}\n\nWord.propTypes = {\n\tword: PropTypes.object,\n\tonSelectWord: PropTypes.func,\n\tisSelected: PropTypes.bool,\n  tempLettersState: PropTypes.array,\n  onRemoveTempLetter: PropTypes.func,\n}\n\nexport default Word","import React from 'react'\nimport PropTypes from 'prop-types'\nimport styled from 'styled-components'\n\nimport Word from './Word'\n\nconst GridContainer = styled(({ gridSize, ...otherProps }) => <div {...otherProps} />)`\n  width: 500px;\n  height: 500px;\n  display: grid;\n  grid-template-columns: repeat(${({ gridSize }) => gridSize}, 1fr);\n  grid-template-rows: repeat(${({ gridSize }) => gridSize}, 1fr);\n  background-color: purple;\n`\n\nconst Board = props => {\n\tconst { puzzle, puzzleState, onSelectWord, selectedWordIndex, tempLettersState, onRemoveTempLetter } = props\n\tconst { gridSize, words } = puzzle\n\n  // all this should go...\n  const fixedWords = []\n  words.forEach((word, wordIndex) => {\n    const fixedText = word.text.map(letter => { return {...letter}})\n    \n    fixedText.forEach((letter, letterIndex) => {\n      letter.isVisible |= puzzleState[wordIndex]?.isLetterDone[letterIndex]\n    })\n    fixedWords.push({...word, text: fixedText})\n  })\n\n  const wordBlocks = fixedWords.map((word, index) =>\n\t\t<Word\n\t\t\tword={word}\n\t\t\tonSelectWord={() => onSelectWord(index)}\n\t\t\tisSelected={index === selectedWordIndex}\n      tempLettersState={tempLettersState}\n      onRemoveTempLetter={onRemoveTempLetter}\n\t\t\tkey={index}\n\t\t/>\n\t)\n\n\treturn (\n\t\t<GridContainer gridSize={gridSize} >\n\t\t\t{wordBlocks}\n\t\t</GridContainer>\n\t)\n}\n\nBoard.propTypes = {\n\tpuzzle: PropTypes.object,\n\tpuzzleState: PropTypes.array,\n\tonSelectWord: PropTypes.func,\n\tselectedWordIndex: PropTypes.number,\n  tempLettersState: PropTypes.array,\n  onRemoveTempLetter: PropTypes.func,\n}\n\nexport default Board","import React from 'react'\nimport PropTypes from 'prop-types'\nimport styled from 'styled-components'\n\nconst Container = styled.div`\n\tdisplay: flex;\n\tflex-direction: row;\n\tjustify-content: center;\n\tborder: 1px solid black;\n  height: 40px;\n  font-size: 35px;\n  text-transform: uppercase;\n  font-family: sans-serif;\n`\n\nconst LetterBlock = styled(({ isUsed, ...otherProps }) => <div {...otherProps} />)`\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  border: 1px solid black;\n  background-color: ${({ isUsed }) => isUsed ? 'rgb(128, 128, 128)' : 'rgb(240, 240, 240)'}} ;\n  margin: 10px;\n  width: 40px;\n  height: 40px;\n  user-select: none;\n`\n\nconst Tray = props => {\n\tconst { letterStates, onPickTempLetter } = props\n\n\tconst handlePickLetter = letterState => {\n\t\tif (!letterState.isUsed) {\n\t\t\tonPickTempLetter(letterState)\n\t\t}\n\t}\n\n\tconst letterBlocks = letterStates.map((letterState, index) => <LetterBlock\n\t\tisUsed={letterState.isUsed}\n\t\tonClick={() => handlePickLetter(letterState)}\n\t\tkey={index}>{letterState.letter}</LetterBlock>)\n\treturn (\n\t\t<Container>\n\t\t\t{letterBlocks}\n\t\t</Container>\n\t)\n}\n\nTray.propTypes = {\n\tletterStates: PropTypes.array,\n\tonPickTempLetter: PropTypes.func\n}\n\nexport default Tray","import React, { useState } from 'react'\nimport PropTypes from 'prop-types'\nimport styled from 'styled-components'\n\nconst PictureContainer = styled.img`\n  height: 200px;\n  background-color: purple;\n  margin: 0 auto;\n  display: block;\n`\n\nconst PictureOverlay = styled.img`\n  position: fixed;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  max-width: 100%;\n  max-height: 100%;\n  margin: auto;\n  overflow: auto;\n  z-index: 2;\n`\n\nconst Picture = props => {\n  const { url } = props\n  const [isBig, setIsBig] = useState(false)\n\n  const handleClick = () => setIsBig(old => !old)\n\n\treturn (\n    <>\n      <PictureContainer src={url} alt='' onClick={handleClick} />\n      {isBig && <PictureOverlay src={url} onClick={handleClick} />}\n    </>\n\t)\n}\n\nPicture.propTypes = {\n\turl: PropTypes.string,\n}\n\nexport default Picture\n","import React from 'react'\nimport styled from 'styled-components'\n\nconst StyledNextButton = styled.button`\n  font-size: 35px;\n  margin: 0 auto;\n  display: block;\n`\n\nconst NextButton = props => {\n  const { onNextLevel } = props\n\n\treturn (\n\t\t<StyledNextButton onClick={onNextLevel}>Next puzzle!</StyledNextButton>\n\t)\n}\n\nexport default NextButton","import React, { useState, useEffect } from 'react'\nimport styled from 'styled-components'\nimport PropTypes from 'prop-types'\n\nimport Board from './Board'\nimport Tray from './Tray'\nimport Picture from './Picture'\nimport NextButton from './NextButton'\n\n\nconst Base = styled.div`\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n`\n\nconst makePuzzleState = (puzzle) => {\n  return puzzle.words.map(word => { return {\n  isDone: false,\n  isLetterDone: Array(word.text.length).fill(false) \n}})\n}\n\nconst Game = props => {\n  const { puzzle, onNextLevel } = props\n  console.log(onNextLevel)\n\n  const [selectedWordIndex, setSelectedWordIndex] = useState(null)\n  const [tempLettersState, setTempLettersState] = useState([])\n  const [letterStates, setLetterStates] = useState([])\n\n  const [isFinished, setIsFinished] = useState(false)\n  const [puzzleState, setPuzzleState] = useState(makePuzzleState(puzzle))\n\n  useEffect(() => {\n    setSelectedWordIndex(null)\n    setTempLettersState([])\n    setIsFinished(false)\n    setPuzzleState(makePuzzleState(puzzle))\n  }, [puzzle])\n\n  // Check if a word was solved\n  useEffect(() => {\n    if (selectedWordIndex === null) return\n\n    const correctAnswer = puzzle.words[selectedWordIndex].text\n    if (tempLettersState.every((tempLetter, i) => tempLetter.tempLetter === correctAnswer[i].letter)) {\n      console.log('correct!')\n      // lock in this word\n      setPuzzleState(p => p.map((wordState, i) => i === selectedWordIndex ? { isDone: true, isLetterDone: new Array(wordState.isLetterDone.length).fill(true)} : wordState))\n      // lock in letters shared with other words\n      for (const letter of correctAnswer) {\n        if (letter.overlap) {\n          // how to do cleanly\n          setPuzzleState(puzzleState => {\n            const { wordIndex, letterIndex } = letter.overlap\n            const newWordState = {...puzzleState[wordIndex]}\n            newWordState.isLetterDone = [...newWordState.isLetterDone]\n            newWordState.isLetterDone[letterIndex] = true\n            return puzzleState.map((wordState, index) => index === wordIndex ? newWordState : wordState)\n          })\n        }\n      }\n\n      // end the attempt\n      setSelectedWordIndex(null)\n      setLetterStates([])\n      // a separate useEffect will check if every word is now solved\n    }\n  }, [tempLettersState, selectedWordIndex, puzzle])\n\n  // is game finished?\n  useEffect(() => {\n    if (puzzleState.every(word => word.isDone)) {\n      setIsFinished(true)\n    }\n  }, [puzzleState])\n\n  const handleSelectWord = index => {\n    if (selectedWordIndex === index) return\n    if (puzzleState[index].isDone) return\n\n    setSelectedWordIndex(index)\n\n    const selectedWord = puzzle.words[index]\n    const newLetterStates = selectedWord.letters.map((letter, index) => ({ letter, isUsed: false, id: index }))\n\n    setTempLettersState(selectedWord.text.map((char, charIndex) => {\n\n      const isVisible = char.isVisible || puzzleState[index].isLetterDone[charIndex]\n      if (isVisible) {\n        const usedIndex = newLetterStates.findIndex(letter => letter.letter === char.letter && !letter.isUsed)\n        newLetterStates[usedIndex].isUsed = true\n      }\n      \n      return {\n        isLocked: isVisible,\n        tempLetter: isVisible ? char.letter : null\n      }\n    })\n    )\n\n    setLetterStates(newLetterStates)\n  }\n\n  const handlePickTempLetter = selectedLetter => {\n    const toUpdateIndex = tempLettersState.findIndex(letter => !letter.isLocked && !letter.tempLetter)\n\n    if (toUpdateIndex === -1) return\n\n    setTempLettersState(tempLettersState.map((letter, index) => (\n      index === toUpdateIndex ? { ...letter, tempLetter: selectedLetter.letter } : { ...letter }\n    ))\n    )\n\n    setLetterStates(letterStates.map(otherLetterState => selectedLetter.id === otherLetterState.id ? { ...otherLetterState, isUsed: true } : otherLetterState))\n  }\n\n  const handleRemoveTempLetter = selectedLetterIndex => {\n      if (tempLettersState[selectedLetterIndex].isLocked) return\n\n      setTempLettersState(tempLettersState.map((letter, index) => (\n        index === selectedLetterIndex ? { ...letter, tempLetter: null } : { ...letter }\n      ))\n      )\n\n      const letterToRestore = tempLettersState[selectedLetterIndex].tempLetter\n      const trayIndex = letterStates.findIndex(letter => letter.isUsed && letter.letter === letterToRestore)\n\n    setLetterStates(letterStates.map((otherLetterState, index) => index === trayIndex ? { ...otherLetterState, isUsed: false } : otherLetterState))\n  }\n\n  return (\n    <Base>\n      <Board\n        puzzle={puzzle}\n        puzzleState={puzzleState}\n        onSelectWord={handleSelectWord}\n        selectedWordIndex={selectedWordIndex}\n        tempLettersState={tempLettersState}\n        onRemoveTempLetter={handleRemoveTempLetter}\n      />\n      <Picture url={puzzle.picture}/>\n      {isFinished && <NextButton onNextLevel={onNextLevel}/>}\n      {!isFinished && <Tray\n        letterStates={letterStates}\n        onPickTempLetter={handlePickTempLetter}\n      />}\n    </Base>\n  )\n}\n\nGame.propTypes = {\n\tpuzzle: PropTypes.object,\n\tonNextLevel: PropTypes.func\n}\n\nexport default Game","import shuffle from 'shuffle-array'\n\nconst Puzzles = []\n\n\nconst randomLetters = \n  ('abcdefghijklmnopqrstuvwxyz'\n  + 'abcdefghijklmnoprstuvwy'\n  + 'aeiou').split('')\n\nfunction randomLetter() {\n  const i = Math.floor(Math.random() * randomLetters.length)\n  return randomLetters[i]\n}\n\nfunction getRandomLettersFor(word) {\n  const result = []\n  for (let i = 0; i < word.length / 3 || i < 3; i++) {\n    result.push(randomLetter())\n  }\n  return result\n}\n\nconst Word = function (text, x, y, direction) {\n  this.text = [...text].map(char => ({ letter: char, isVisible: false }))\n  this.coords = { x, y }\n  this.letters = [...text, ...getRandomLettersFor(text)]\n  shuffle(this.letters)\n  this.direction = direction\n}\n\nPuzzles.push({\n  picture: '1.jpg',\n  gridSize: 10,\n  words: [\n    new Word('glasses', 1, 4, 'row'),\n    new Word('desk', 4, 2, 'column'),\n    new Word('laptop', 2, 4, 'column'),\n    new Word('notebook', 1, 8, 'row'),\n  ]\n})\n\nPuzzles.push({\n  picture: '2.jpg',\n  gridSize: 11,\n  words: [\n    new Word('hills', 1, 1, 'row'),\n    new Word('sunset', 5, 1, 'column'),\n    new Word('water', 3, 6, 'row'),\n    new Word('friends', 7, 5, 'column'),\n  ]\n})\n\nfor (const puzzle of Puzzles) {\n  // Find overlapping letters\n  for (const word of puzzle.words) {\n    let x = word.coords.x\n    let y = word.coords.y\n    for (let i = 0; i < word.text.length; i++) {\n      for (const otherWord of puzzle.words) {\n        if (otherWord !== word) {\n          let x2 = otherWord.coords.x\n          let y2 = otherWord.coords.y\n          for (let j = 0; j < otherWord.text.length; j++) {\n            if (x2 === x && y2 === y) {\n              // an overlap\n              word.text[i].overlap = { wordIndex: puzzle.words.indexOf(otherWord), letterIndex: j} \n            }\n            if (otherWord.direction === 'row') {\n              x2++\n            } else {\n              y2++\n            }\n          }\n        }\n      }\n      if (word.direction === 'row') {\n        x++\n      } else {\n        y++\n      }\n    }\n  }\n}\n\nexport default Puzzles","import React, { useState } from 'react'\nimport Game from './game/Game'\nimport Puzzles from './game/Puzzles'\n\nconst App = () => {\n  const [currentLevel, setCurrentLevel] = useState(0)\n  const handleNextLevel = () => {\n    setCurrentLevel(oldLevel => oldLevel + 1)\n  }\n\n  return (\n    <Game \n      puzzle={Puzzles[currentLevel % Puzzles.length]}\n      onNextLevel={handleNextLevel}\n    />\n  )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\nimport * as serviceWorker from './serviceWorker'\n\nReactDOM.render(<App />, document.getElementById('root'))\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n"],"sourceRoot":""}